## inttypes和数据类型


引入：
c语言的格式控制字符串，就是`%s, %d`这些，有一个特性。
```c
printf("%s", "haizei");
printf("%" "s", "hai" "zei");
```
这两行代码的效果是一样的，也就是个是控制字符串有一种特性——即可用空格和双引号分割，出来的效果是一样的。
那么知道了这个就可以引入`inttypes`头文件中的若干宏。
```c
int16_t a;
scanf("%" PRId16, &a);
printf("%" PRId16 "\n, a");
```
这样就实现了一个打印16位短整形的功能，这里的PRId实际上是一个宏定义。
我们打印`printf("%s", PRId16);`
出来是hd，PRId32就是d，以此类推。
这里的d是decimal，即十进制，以此类推八进制o-octal,十六进制x-Hexadecimal

## inttypes中的极大值和极小值

`INT64_MAX`

## 左值和右值

以下面一份代码为例：
```c
sdasdasdadasdw
int main() {
    int a, b = 3, c = 4;
    a = 3 + 4;
    b = c;mZ}
```
如果这里的(3+4)和c一样都是左值，那么他们必然可以进行同一种操作，不放用自增来检验。
```c

int main() {
    int a, b = 3, c = 4;
    a = ++(3 + 4);
    b = ++c;
}
```
但是这时编译器汇报错:expression is not assignable.即3+4不是左值。
是因为3和4是数字的问题吗。那么不妨将其换成变量：
```c
int main() {
    int a, b = 3, c = 4, d = 3, e = 4;
    a = ++(d + e);
    b = ++c;
}

```
但是换完之后还是一样的问题。
所以有左值和右值不是以他是在等式的左边或者是右边来去分的，而是通过**代码运行到下一行还能不能访问到这个值来确定的**。
比如50行的d+e作为一个中间量被储存了起来，在下一行就无法访问到这个中间量了。
所以51行的++c是一个左值，可以(++c)++

## 运算符运算顺序

着重介绍异或`^`
若`a ^ b = c, 有b ^ c = a`
即异或为自己的逆运算。
这里明确一点即位运算适合自己所在的位有关，和抬得前一位有一位无关。
假设a的相关位为1,b的相关位为0,xor之后是1,也就是xor在统计两位1的奇偶性。
有这几种可能:
    1. 奇奇偶
    2. 奇偶奇
    3. 偶偶偶

与运算看作乘法，或运算看作加法。











